---
title: 2021年07月12日 数组习题
categories:
  - 随堂笔记
  - 2021年07月
abbrlink: 13e87ce3
date: 2021-07-12 14:14:00
updated: 2021-07-12 14:14:00
---
#  1、在一个数组中找出最大和最小值，并输出它们的位置；
```java FindMaxAndMinInArray.java
public class FindMaxAndMinInArray {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int[] a = new int[10];
		System.out.print("输入10个数:");
		for (int i = 0; i < a.length; i++) {
			a[i] = scanner.nextInt();
		}
		int maxIndex = 0, minIndex = 0;
		for (int i = 1; i < a.length; i++) {
//			如果找到一个更大的数
			if (a[i] > a[maxIndex]) {
				maxIndex = i;
			}
//			如果找到一个更小的数
			if (a[i] < a[minIndex]) {
				minIndex = i;
			}
		}
//		输出最大最小值
		System.out.println("最大值：a[" + maxIndex + "]=" + a[maxIndex] + "，最小值：a[" + minIndex + "]=" + a[minIndex]);
	}
}
```
# 2、冒泡法对一个数组排序；
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。
https://www.runoob.com/w3cnote/bubble-sort.html

https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#4
```java
/**
  * 冒泡排序，默认升序排列。
  * 如果数组已经有序，则不再排序。
  * @param array
  */
private static void bubbleSortBetter(int[] array) {
    swapTimes2=0;
//		添加一个判断是否交换的标记
    boolean haveSwap=false;
    for (int i = 0,temp; i < array.length-1; i++) {
        haveSwap=false;
        for (int j = 0; j < array.length-1-i; j++) {
//				如果前一个数比后一个数大
            if(array[j]>array[j+1]) {
                temp=array[j];
//					小的数放前面
                array[j]=array[j+1];
//					大的数放后面
                array[j+1]=temp;
//					经过交换
                haveSwap=true;
                swapTimes2++;
            }
        }
//			如果一轮比较之后,没有交换，则说明已经有序，不需要再排序了
        if(!haveSwap) {
            break;
        }
    }
}
```
# 3、 选择法对数数组排序；
https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95
https://www.runoob.com/w3cnote/selection-sort.html
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：
第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。
选择排序是不稳定的排序方法。

- 首先在未排序序列中找到最小（大）元素，存放到**排序序列**的起始位置。
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已**排序序列**的末尾。
- 重复第二步，直到所有元素均排序完毕。


```java
/**
 * 选择排序，升序排序
 * 每次选择一个最小的值放到没有排序的序列的前方。
 * @param a 待排序的数组。
 */
private static void selectionSort(int[] a) {
	// n个元素，需要比较n-1次（2个元素，比较1次，3个元素，比较两次）
	for (int i = 0, temp; i < a.length - 1; i++) {
//			默认最小值
		int min = i;
		// 遍历没有排序的元素
		for (int j = i + 1; j < a.length; j++) {
//				如果找到更小的值
			if (a[j] < a[min]) {
//					记录下这个更小的值
				min = j;
			}
		}
//			如果找到了更小的值
		if (min > i) {
			temp = a[min];
			a[min] = a[i];
			a[i] = temp;
		}
	}
}
```
# 4、把一个十进制数转换成十六进制的数；
https://zh.wikihow.com/%E6%8A%8A%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0

和十进制转2进制的做法一样，除以16，取余数，然后逆序排列即可。

# 5、实现一个数组的逆序存储
```java ReverseStoredInTheArray.java
/**
 * 逆序存储到数组中
 *
 */
public class ReverseStoredInTheArray {

	public static void main(String[] args) {
		int[] a=new int[10];
		Scanner scanner=new Scanner(System.in);
		for (int i = 0; i < a.length; i++) {
			a[a.length-1-i]=scanner.nextInt();
		}
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i]+" ");
		}
	}
}
```
# 6、在一个有序的数组插入一个数，也保证有序；



# 7、在一个有序的数组中，利用折半法进行查找；
https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE
https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95

# 8、矩阵的倒置；