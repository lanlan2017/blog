---
title: 2021年07月12日 数组习题
categories:
  - 随堂笔记
  - 2021年07月
abbrlink: 13e87ce3
date: 2021-07-12 14:14:00
updated: 2021-07-12 14:14:00
---
#  1、在一个数组中找出最大和最小值，并输出它们的位置；
```java FindMaxAndMinInArray.java
public class FindMaxAndMinInArray {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int[] a = new int[10];
		System.out.print("输入10个数:");
		for (int i = 0; i < a.length; i++) {
			a[i] = scanner.nextInt();
		}
		int maxIndex = 0, minIndex = 0;
		for (int i = 1; i < a.length; i++) {
//			如果找到一个更大的数
			if (a[i] > a[maxIndex]) {
				maxIndex = i;
			}
//			如果找到一个更小的数
			if (a[i] < a[minIndex]) {
				minIndex = i;
			}
		}
//		输出最大最小值
		System.out.println("最大值：a[" + maxIndex + "]=" + a[maxIndex] + "，最小值：a[" + minIndex + "]=" + a[minIndex]);
	}
}
```
# 2、冒泡法对一个数组排序；
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。
https://www.runoob.com/w3cnote/bubble-sort.html

https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#4
```java
/**
  * 冒泡排序，默认升序排列。
  * 如果数组已经有序，则不再排序。
  * @param array
  */
private static void bubbleSortBetter(int[] array) {
    swapTimes2=0;
//		添加一个判断是否交换的标记
    boolean haveSwap=false;
    for (int i = 0,temp; i < array.length-1; i++) {
        haveSwap=false;
        for (int j = 0; j < array.length-1-i; j++) {
//				如果前一个数比后一个数大
            if(array[j]>array[j+1]) {
                temp=array[j];
//					小的数放前面
                array[j]=array[j+1];
//					大的数放后面
                array[j+1]=temp;
//					经过交换
                haveSwap=true;
                swapTimes2++;
            }
        }
//			如果一轮比较之后,没有交换，则说明已经有序，不需要再排序了
        if(!haveSwap) {
            break;
        }
    }
}
```
# 3、 选择法对数数组排序；
https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95
https://www.runoob.com/w3cnote/selection-sort.html
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：
第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。
选择排序是不稳定的排序方法。

- 首先在未排序序列中找到最小（大）元素，存放到**排序序列**的起始位置。
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已**排序序列**的末尾。
- 重复第二步，直到所有元素均排序完毕。


```java
/**
 * 选择排序，升序排序
 * 每次选择一个最小的值放到没有排序的序列的前方。
 * @param a 待排序的数组。
 */
private static void selectionSort(int[] a) {
	// n个元素，需要比较n-1次（2个元素，比较1次，3个元素，比较两次）
	for (int i = 0, temp; i < a.length - 1; i++) {
//			默认最小值
		int min = i;
		// 遍历没有排序的元素
		for (int j = i + 1; j < a.length; j++) {
//				如果找到更小的值
			if (a[j] < a[min]) {
//					记录下这个更小的值
				min = j;
			}
		}
//			如果找到了更小的值
		if (min > i) {
			temp = a[min];
			a[min] = a[i];
			a[i] = temp;
		}
	}
}
```
# 4、把一个十进制数转换成十六进制的数；
https://zh.wikihow.com/%E6%8A%8A%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0

和十进制转2进制的做法一样，除以16，取余数，然后逆序排列即可。

```java
public class DecimalToHexadecimal {

	public static void main(String[] args) {
		// 被除数，十进制数
		int dividend = 16 + 15;
		// 除16取余
		int[] remainders = decimalToHexadecimal(dividend);
		// 逆序打印余数
		System.out.println("(" + dividend + ")10 = (" + printHexadecimal(remainders) + ")16");
	}

	/**
	 * 十进制转十六进制
	 * 除16取余，逆序排列
	 * 
	 * @param remainders 保存每个余数的数组
	 * @param remainderCounter 到底有多少个余数
	 * @return
	 */

	private static int[] decimalToHexadecimal(int dividend) {
		// 创建一个临时的数组用来，保存余数
		int[] remainderTemps = new int[20];
		int remainderCounter = 0;
		// 十进制数(被除数)
		// int dividend = 16 + 15;
		// 定义商
		int quotient;
		do {
			// 求商
			quotient = dividend / 16;
			// 求余数
			remainderTemps[remainderCounter++] = dividend % 16;
			// 商作为下次的被除数
			dividend = quotient;
		} while (dividend > 0);
		// 创建一个刚好能保存所有余数的数组
		int[] remainders = new int[remainderCounter];
		// 从临时保存的余数数组中拷贝到
		for (int i = 0; i < remainders.length; i++) {
			remainders[i] = remainderTemps[i];
		}
		// 返回保存余数的数组
		return remainders;
	}

	/**
	 * 打印16进制数
	 * 
	 * @param remainders 保存余数的数组。
	 */
	private static String printHexadecimal(int[] remainders) {
		StringBuffer sb = new StringBuffer(remainders.length);
		// 十进制转十六进制口诀：除16取余，逆序排列
		// 逆序打印
		for (int i = remainders.length - 1; i >= 0; i--) {
			if (remainders[i] < 10) {
				// System.out.print(remainders[i]);
				sb.append(remainders[i]);
			} else {
				// System.out.print((char) ('A' + remainders[i] - 10));
				sb.append((char) ('A' + remainders[i] - 10));
			}
		}
		return sb.toString();
	}
}
```
# 5、实现一个数组的逆序存储
```java ReverseStoredInTheArray.java
/**
 * 逆序存储到数组中
 *
 */
public class ReverseStoredInTheArray {

	public static void main(String[] args) {
		int[] a=new int[10];
		Scanner scanner=new Scanner(System.in);
		for (int i = 0; i < a.length; i++) {
			a[a.length-1-i]=scanner.nextInt();
		}
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i]+" ");
		}
	}
}
```
# 6、在一个有序的数组插入一个数，也保证有序；
```java
public class OrderedArrayIsStillOrderedAfterInsertion {

	public static void main(String[] args) {
		// 保存有序序列的数组
		int[] a = new int[20];
		// 有序序列
		int[] b = { 1, 5, 9, 18, 24 };
		// 把有序序列保存到数组中
		for (int i = 0; i < b.length; i++) {
			a[i] = b[i];
		}
		System.out.println("有序序列：");
		printArray(a);

		int toBeInsert;
		// Scanner scanner = new Scanner(System.in);
		// System.out.println("输入一个整数:");
		// toBeInsert=scanner.nextInt();

		// 插入有序序列的最前面
		// toBeInsert = 0;
		// 插入有序序列的中间
		// toBeInsert = 8;
		// toBeInsert = 23;
		// 插入有序序列的最后面
		toBeInsert = 25;
		System.out.println("要插入的元素:" + toBeInsert);
		// 找出要出插入的位置
		int insetIndex = findInsertIndex(a, b.length - 1, toBeInsert);
		System.out.println("插入后的位置：" + insetIndex);
		// 为要插入的元素腾出空间
		makeRoomForInsertion(a, b.length, insetIndex);
		System.out.println("为待插入元素腾出空间：");
		printArray(a);
		// 插入要插入的元素
		a[insetIndex] = toBeInsert;
		System.out.println("插入后的效果：");
		printArray(a);
	}

	/**
	 * 查找要插入的元素在有序数组中将要插入的位置。
	 * 
	 * @param a 有序数组
	 * @param orderedSequenceEndIndex 有序数组中最后的元素的下标。
	 * @param toBeInserted 要插入的元素
	 * @return
	 */
	private static int findInsertIndex(int[] a, int orderedSequenceEndIndex, int toBeInserted) {
		int insetIndex = 0;
		int i = 0;
		for (; i <= orderedSequenceEndIndex; i++) {
			// 如果输入的比扫描到的数小
			if (toBeInserted < a[i]) {
				// 则应该在这里插入输入的数
				insetIndex = i;
				break;
			}
		}
		if (insetIndex == 0) {
			insetIndex = i;
			return insetIndex;
		}
		return insetIndex;
	}

	/**
	 * 为要插入的元素腾出空间
	 * 
	 * @param a 保存有序序列的数组
	 * @param lastIndexOfNew 插入元素之后形成的新的有序序列的最后一个元素的下标
	 * @param insetIndex 要插入的下标
	 */
	private static void makeRoomForInsertion(int[] a, int lastIndexOfNew, int insetIndex) {
		// 如果要插入的位置，在原来有序序列的最后面
		if (insetIndex == lastIndexOfNew) {
			// 那么不需要平移元素
			return;
		}
		// 从后向前扫描
		for (int i = lastIndexOfNew + 1, temp; i > insetIndex; i--) {
			// 所有的元素往后移动一格
			temp = a[i];
			a[i] = a[i - 1];
		}
	}

	/**
	 * 打印数组
	 * 
	 * @param a 待打印数组
	 */
	private static void printArray(int[] a) {
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i]);
			if (i < a.length - 1)
				System.out.print(",");
		}
		System.out.println();
	}
}
```

# 7、在一个有序的数组中，利用折半法进行查找；
https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE
https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95

## 二分查找

```java
/**
 * 二分查找。
 * 
 * @param a 有序数组
 * @param toFind 要查找的整数
 * @return 如果在数组中查找到该元素，则返回该元素的索引，
 *         否则返回-1表示在数组找不到这个元素。
 */
private static int binarySearch(int[] a, int toFind) {
	// 查找序列的开始位置
	int start = 0;
	// 查找序列的结束位置
	int end = a.length - 1;
	int middle;
	while (start <= end) {
		middle = (start + end) / 2;
		// 如果待查找的等于中间值，则说明查找到了，输出该元素的位置
		if (a[middle] == toFind) {
			// System.out.println(toFind + "位于：" + middle + "位置");
			// break;
			// 返回待查找元素的下标
			return middle;
		}
		// 如果待查元素比中间位置的值大，应该到后面的序列去查找
		else if (toFind > a[middle]) {
			// 修改待查找的序列的起始位置为中间值的后一个位置
			start = middle + 1;
		}
		// 如果待查元素比中间值小，应该到前面去查找
		else {
			// 修改待查找的序列的结束位置为中间位置的前面一个位置
			end = middle - 1;
		}
	}
	// 返回一个负数作为下标，表示没有查找到该元素
	return -1;
}
```

## 测试

```java
public static void main(String[] args) {
	int[] a = { 1, 2, 7, 8, 9, 10, 23, 45, 67, 89, 98, 123, 134 };
	int toFind = 9;
	
	int index = 0;
	if ((index = binarySearch(a, toFind)) >= 0) {
		System.out.println("数组中  存在" + toFind + "这个元素,a[" + index + "]=" + a[index]);
	} else {
		System.out.println("数组中 不存在" + toFind + "这个元素");
	}
}
```

## 运行结果

```
数组中  存在9这个元素,a[4]=9
```



# 8、矩阵的倒置；

## 水平镜像矩阵

```java
/**
 * 水平镜像矩阵，上面的行保存到下面，下面的行保存到上面。
 * 
 * @param a 保存矩阵的二维数组
 */
private static void mirrorHorizontalMatrix(int[][] a) {
	int temp;
	for (int i = 0; i <= (a.length - 1) / 2; i++) {
		for (int j = 0; j < a[i].length; j++) {
			temp = a[i][j];
			a[i][j] = a[a.length - 1 - i][j];
			a[a.length - 1 - i][j] = temp;
		}
	}
}
```

## 垂直镜像矩阵

```java
/**
 * 对矩阵做垂直镜像操作
 * 
 * @param a 保存矩阵的二维数组。
 */
private static void mirrorVertical(int[][] a) {
	int temp;
	for (int i = 0; i < a.length; i++) {
		for (int j = 0; j <= (a[0].length - 1) / 2; j++) {
			temp = a[i][j];
			a[i][j] = a[i][a[i].length - 1 - j];
			a[i][a[i].length - 1 - j] = temp;
		}
	}
}
```

## 测试

```java
int[][] a = { 
		{ 1, 2, 3 }, 
		{ 4, 5, 6 }, 
		{ 7, 8, 9 } };
printMatrix(a);
// 水平镜像矩阵
mirrorHorizontalMatrix(a);
printMatrix(a);
// 垂直镜像矩阵
mirrorVertical(a);
printMatrix(a);
```

## 运行结果

```
|01,02,03|
|04,05,06|
|07,08,09|

|07,08,09|
|04,05,06|
|01,02,03|

|09,08,07|
|06,05,04|
|03,02,01|
```

# 9、矩阵相加