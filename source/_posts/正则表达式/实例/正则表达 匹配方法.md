---
title: 正则表达 匹配方法
categories: 
  - 正则表达式
  - 实例
date: 2019-05-16 19:07:02
updated: 2019-11-25 13:24:47
abbrlink: e8358348
---
<div id='my_toc'>

- [前言](/blog/e8358348/#前言)
- [匹配方法的正则表达式](/blog/e8358348/#匹配方法的正则表达式)
- [匹配gettter setter方法](/blog/e8358348/#匹配gettter-setter方法)
- [正则表达式分析](/blog/e8358348/#正则表达式分析)
- [Java代码实现](/blog/e8358348/#Java代码实现)
    - [从类源码之中删除getter和setter方法](/blog/e8358348/#从类源码之中删除getter和setter方法)
    - [删除空行的代码](/blog/e8358348/#删除空行的代码)
    - [从剪贴板中获取文本的代码](/blog/e8358348/#从剪贴板中获取文本的代码)
    - [运行结果](/blog/e8358348/#运行结果)
        - [测试输入文本](/blog/e8358348/#测试输入文本)
        - [运行结果](/blog/e8358348/#运行结果)
    - [不足的地方](/blog/e8358348/#不足的地方)
- [改进](/blog/e8358348/#改进)
    - [匹配正则](/blog/e8358348/#匹配正则)
    - [新的问题](/blog/e8358348/#新的问题)
    - [匹配getter setter方法](/blog/e8358348/#匹配getter-setter方法)
- [在线正则表达式匹配工具](/blog/e8358348/#在线正则表达式匹配工具)

</div>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}</script>

<!--end-->
# 前言 #
最近往博客中粘贴代码时,有些方法是IDE自动生成的,例如getter方法和setter方法.限于篇幅,我不想把这些IDE自动生成的getter和setter方法粘贴到我博客中.
**所以我想在复制粘贴代码到文章的时候,利用表达式把这些getter和setter方法删除掉.**
# 匹配方法的正则表达式 #
```
public\s+(?:\w+(?:\s+)?)+\((?:\,?\s*\w+\s+\w+)*\)\s+\{(?:(?:\n|\r\n).*?)*?\}
```
匹配效果如下图所示:
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/regex/example/Method/1.png)
# 匹配gettter setter方法 #
```
public\s+\w+\s+(?:set|get)\w+\((?:\,?\s*\w+\s+\w+)*\)\s+\{(?:(?:\n|\r\n).*?)*?\}
```
匹配效果如下图所示:
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/regex/example/Method/2.png)
# 正则表达式分析 #
下面的正则表达式匹配了方法的形式参数列表和方法体之中的代码.
```
\((?:\,?\s*\w+\s+\w+)*\)\s+\{(?:(?:\n|\r\n).*?)*?\}
```
# Java代码实现 #
## 从类源码之中删除getter和setter方法 ##
```java
public class MDCodeBlockJavaNoGetterSetter
{
    public static void main(String[] args)
    {
        System.out.println(javaNoGetterSetter());
    }
    public static String javaNoGetterSetter()
    {
        String input = SysClipboardUtil.getSysClipboardText();
        System.out.println(input);
        System.out.println("-----------------------------------------------");
        Pattern getterSetterPattern = Pattern.compile(
                "public\\s+\\w+\\s+(?:set|get)\\w+\\((?:\\,?\\s*\\w+\\s+\\w+)*\\)\\s+\\{(?:(?:\\n|\\r\\n).*?)*?\\}");
        Matcher getterSetterMatcher = getterSetterPattern.matcher(input);
        boolean isFirst = true;
        StringBuffer sb = new StringBuffer();
        while (getterSetterMatcher.find())
        {
            // 第一次匹配的时候加上提示标记
            if (isFirst)
            {
                // 替换匹配到的结构,并将替换后的内容追加到之中
                getterSetterMatcher.appendReplacement(sb,
                        "// 此处省略getter和setter方法,请自己补上");
                isFirst = false;
            } else
            {
                // 其他的地方直接删除
                getterSetterMatcher.appendReplacement(sb, "");
            }
        }
        // 剩下没有匹配的也追加到sb之中.
        getterSetterMatcher.appendTail(sb);
        // 删除空行
        input = Delete.deleteBlankLine(sb.toString());
        return input;
    }
}
```
## 删除空行的代码 ##
```java
publicclassDelete
{
    publicstaticStringdeleteBlankLine(Stringtext)
    {
        text=text.replaceAll("(?m)(?:\\n|\\r\\n)(?:^\\s*$)","");
        text=text.replaceAll("(?m)(?:^\\s*$(?:\\n|\\r\\n))","");
        returntext;
    }
}
```
## 从剪贴板中获取文本的代码 ##
```java
public class SysClipboardUtil
{
    /**
     * 从剪贴板中获取文本.
     * @return 如果剪贴板中没有文本,则返回null.如果获取到文本,则返回文本.
     */
    public static String getSysClipboardText()
    {
        String text = null;
        Clipboard sysClip = Toolkit.getDefaultToolkit().getSystemClipboard();
        // 获取剪切板中的内容
        Transferable clipTf = sysClip.getContents(null);
        if (clipTf != null)
        {
            // 检查内容是否是文本类型
            if (clipTf.isDataFlavorSupported(DataFlavor.stringFlavor))
            {
                try
                {
                    // 转换为文本
                    text = (String) clipTf
                            .getTransferData(DataFlavor.stringFlavor);
                } catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }
        return text;
    }
}
```
## 运行结果 ##
### 测试输入文本 ###
```java
import java.io.Serializable;
public class Book implements Serializable {
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String name;
    private String author;
    public Book() {
        super();
        // TODO Auto-generated constructor stub
    }
    public Book(Integer id, String name, String author) {
        super();
        this.id = id;
        this.name = name;
        this.author = author;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getAuthor() {
        return author;
    }
    public void setAuthor(String author) {
        this.author = author;
    }
    @Override
    public String toString() {
        return "Book [id=" + id + ", name=" + name + ", author=" + author + "]";
    }
}
```
### 运行结果 ###
```
import java.io.Serializable;
public class Book implements Serializable {
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String name;
    private String author;
    public Book() {
        super();
        // TODO Auto-generated constructor stub
    }
    public Book(Integer id, String name, String author) {
        super();
        this.id = id;
        this.name = name;
        this.author = author;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getAuthor() {
        return author;
    }
    public void setAuthor(String author) {
        this.author = author;
    }
    @Override
    public String toString() {
        return "Book [id=" + id + ", name=" + name + ", author=" + author + "]";
    }
}
-----------------------------------------------
import java.io.Serializable;
public class Book implements Serializable {
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String name;
    private String author;
    public Book() {
        super();
        // TODO Auto-generated constructor stub
    }
    public Book(Integer id, String name, String author) {
        super();
        this.id = id;
        this.name = name;
        this.author = author;
    }
    // 此处省略getter和setter方法,请自己补上
    @Override
    public String toString() {
        return "Book [id=" + id + ", name=" + name + ", author=" + author + "]";
    }
}
```
可以看到`getter`方法和`setter`方法已经从代码之中移除出去了,这样我们**写文章的时候代码比较紧凑,便于阅读**.
## 不足的地方 ##
这个正在表达式不适合方法体之中存在代码快的情况.因为它以`}`作为方法的介绍标记.但是如果此时方法体重存在`}`这个符号,将不会匹配成功.
# 改进 #
上面的代码并不能匹配到方法体之中有嵌套的代码块的情况.
## 匹配正则 ##
```
public\s+(?:\w+(?:\s+)?)+\((?:\,?\s*\w+\s+\w+)*\)(\s+)\{(?:(?:\n|\r\n).*)*?\1\}
```
上面正则判断方法的代码如下:
```
(\s+)\{(?:(?:\n|\r\n).*)*?\1\}
```
通过匹配方法体开始标记`(\s+)\{`和结束标记`\1\}`前面的空格判断方法体的开始和结束位置.匹配效果如下图:
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/regex/example/Method/3.png)
这样就可以匹配到如下所示的代码:
```
    public static String oneArg(String arg1)
    {
        //从剪贴板获取文本
        String text=SysClipboardUtil.getSysClipboardText();
        // 删除空行
        text = text.replaceAll("(?m)^\\s*$(\\n|\\r\\n)", "");
        switch (arg1)
        {
        //省略...
        }
        return text;
    }
    public static String noArg(String text)
    {
        // 删除无用的空行
        text = text.replaceAll("(?m)^\\s*$(\\n|\\r\\n)", "");
        return text;
    }
```
## 新的问题 ##
好的现在又引入了新的问题,如果是下面的代码:
```
    public void setName(String name) {
        this.name = name;
    }
```
上述正则将无法匹配到.因为方法体开始符`{`前面只有一个空格,而结束符前面却有4个空格。
嗯,这个事情暂且搁置.就让自己手动现在使用哪种方式吧.
## 匹配getter setter方法 ##
```
public\s+\w+\s+(?:set|get)\w+\((?:\,?\s*\w+\s+\w+)*\)(\s+)\{(?:(?:\n|\r\n).*)*?\1\}
```
匹配效果如下图图所示:
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/regex/example/Method/4.png)

# 在线正则表达式匹配工具 #
[http://tool.chinaz.com/regex/](http://tool.chinaz.com/regex/)

>原文链接: [正则表达 匹配方法](https://lanlan2017.github.io/blog/e8358348/)
