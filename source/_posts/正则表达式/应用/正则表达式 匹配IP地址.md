---
title: 正则表达式 匹配IP地址
categories: 
  - 正则表达式
  - 应用
date: 2018-08-19 19:39:36
updated: 2019-12-17 05:18:53
abbrlink: 9e1b6b70
---
<div id='my_toc'><a href="/blog/9e1b6b70/#匹配一个合法的数字" class="header_2">匹配一个合法的数字</a>&nbsp;<br><a href="/blog/9e1b6b70/#三位数的情况：" class="header_3">三位数的情况：</a>&nbsp;<br><a href="/blog/9e1b6b70/#两位数的情况" class="header_3">两位数的情况</a>&nbsp;<br><a href="/blog/9e1b6b70/#一位数的情况" class="header_3">一位数的情况</a>&nbsp;<br><a href="/blog/9e1b6b70/#匹配一个合法的数字" class="header_3">匹配一个合法的数字</a>&nbsp;<br><a href="/blog/9e1b6b70/#优化：" class="header_3">优化：</a>&nbsp;<br><a href="/blog/9e1b6b70/#匹配一个合法的数字和点号三次-##：" class="header_2">匹配一个合法的数字和点号三次 ##：</a>&nbsp;<br><a href="/blog/9e1b6b70/#最终的表达式：" class="header_2">最终的表达式：</a>&nbsp;<br><a href="/blog/9e1b6b70/#优化：" class="header_3">优化：</a>&nbsp;<br><a href="/blog/9e1b6b70/#总结" class="header_2">总结</a>&nbsp;<br><a href="/blog/9e1b6b70/#匹配IP地址中的一个数" class="header_3">匹配IP地址中的一个数</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
正则表达式匹配IP地址


> 正则表达式，又称规则表达式。接下来通过本文给大家介绍正则表达式匹配`IP`的表达式，非常不错，具有参考借鉴价值，需要的的朋友参考下吧

这里给大家详细讲解一下一个匹配IP地址的正则表达式，
有关正则方面的知识，会在详细的讲解中提到。
在讲解之前，我先给大家介绍一下，ip地址的生成规则。
IP地址，是由32位数字二进制转为四个十进制的字符串组成。
怎么转化？下面讲解：

二进制：`11111111111111111111111111111111`
分为四部分：`11111111.11111111.11111111.11111111`
转化：`2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0=255`
转为十进制范围：`0~255.0~255.0~255.0~255`
这就是`IP`地址的范围。
根据这个生成`IP`的规则和范围，我们可以用正则表达式来匹配出`IP`地址，但怎么匹配呢？各人有各人的方法，这里我讲解一下我的思路。


根据IP地址的字符串规律，我把匹配IP地址的表达式分为两部分来考虑。
第一部分：匹配3个`0~255.`（注意后面的一个点）
第二部分：匹配最后的数字`0~255`
也就是说，**先匹配出` 0~255.`（注意后面的一个点） 这个字符串，然后重复匹配3次，然后再匹配最后的数字部分0~255**。这就是我匹配`IP`地址的思路。

首先，我要提一下**，正则是没有办法做数字运算的**，所以，我们无法用数字运算的方式筛选出IP的数字范围。既然没法用数字运算的方式筛选出IP的数字范围，那么我们应该用什么其他方式来筛选这个数字范围呢？我的思路是分组讨论，然后再把这些分组合并起来组成IP的数字范围。
## 匹配一个合法的数字 ##

### 三位数的情况： ###
- 假设百位是`2`，那么根据`IP`数字的范围规则，这里又要分为两种情况，为什么？你想想，最大数字是`255`，当十位数为`5`时，个位数最大只能为`5`是吧？(`250-255`).而当十位数为`0到4`时，个位数可以是任意数字对吧？(`200-249`)
所以，这里的两种情况分别为：
    - `2[0-4][0-9]`
    - `25[0-5]`
- 假设百位数是`1`，那么这个数字的范围为`100-199`,对应正则表达式就为`1[0-9][0-9]`。这个应该不难理解，就不解释。

### 两位数的情况 ###
分析完了三位数数的情况，接下来就是两数的情况了，假如是两位数，那么十位数的前面第一个数不能为零是吧？也就是范围为`10-99`(`10,11...,19,20,...,99`),对应的正则表达式为`[1-9][0-9]`
### 一位数的情况 ###
剩下的就是个位数的情况了，个位数的情况，大家应该很容易得出结论，就是：`[0-9]`。

四种情况分析下来，我们得出了IP数字的范围分组为：
- `25[0-5]`
- `2[0-4][0-9]`
- `1[0-9][0-9]`
- `[1-9][0-9]`
- `[0-9]`

### 匹配一个合法的数字 ###
所以匹配IPv4中一个和法的数组的正则表达式为`(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`

### 优化： ###
- 可以把两位数`[1-9][0-9]`和一位数的情况`[0-9]`合并，写为`[1-9]?[0-9]`.
- 用简写`\d`替代`[0-9]`

所以优化后的一个合法的数字的正则表达式为：`(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)`

## 匹配一个合法的数字和点号三次 ##：
点号要转义为`\.`,
`((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}`

## 最终的表达式： ##
三组数字和点号之后，后面还有一组数字。这样的话综合起来就是：
`((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)`

### 优化： ###
上面我们使用了括号`(...)`来限定量词和多选的作用范围。但是这样也会在匹配的时候进行捕获，捕获的话会造成不必要的开销，这里使用`(?:...)`来限定，这样省去捕获分组的开销。
`(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)`
测试：

## 总结 ##
### 匹配IP地址中的一个数 ###
支持0开头,捕获分组:
```
(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)
```
不支持0开头,不捕获分组:
```
(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)
```
不支持0开头,匹配整个IP地址
```
(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)
```
![](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/java/my_regex_example/IP/IP_match_only.svg)
匹配整个IP地址，并捕获每个数字:
```
(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)
```
![](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/java/my_regex_example/IP/IP_match_group.svg)
